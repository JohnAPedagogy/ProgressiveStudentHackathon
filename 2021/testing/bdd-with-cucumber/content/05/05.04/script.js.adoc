include::./title.adoc[]

shot::[1,open feature file]

The way that we’ve specified this data is OK,

.hear_shout.feature
[source,gherkin]
----
include::../code/js/10-changed-other-scenario-and-deleted-unused-stepdef/features/hear_shout.feature[lines=13..31]
----

but your product owner would prefer you to express it like this instead: shot::[2,edit data table to have headings in the first column]

.hear_shout.feature
[source,gherkin]
----
include::../code/js/12-transpose-annotation/features/hear_shout.feature[lines=15..29]
----

It's always good to please the product owner, but you’re worried how we’ll handle it in our step definition? Fear not. Cucumber has you covered.

If you call the `transpose` method on the table shot::[3, stepdef], Cucumber will turn each row into a column before passing it to the step definition.

.steps.js
[source, js]
----
include::../code/js/12-transpose-annotation/features/step_definitions/steps.js[lines=22]
----

shot::[4,run cucumber]

shot::[5, show data tables in feature file]
Data tables are very useful for setting up data in Given steps, but you can also use them for specifying outcomes.

One rule that we’ve been implying but have never actually explored with an example is that people can hear more than one shout. So far we’ve only specified a single message, so let’s try writing a scenario where Sean shouts more than once: shot::[6, write two-shouts scenario]

.hear_shout.feature
[source,gherkin]
----
include::../code/js/13-deepequal/features/hear_shout.feature[lines=31..40]
----

See how natural it is to use a Data Table here? We also haven’t used any column headers in this case, since the data is all in a single column anyway.

So how do we implement this step definition? Well, the Javascript assert class has a really handy method called deepEqual that we can use to compare two Data Tables. deepEqual will pass if the tables are the same, and fail if they’re different.

Let's run Cucumber to generate the new step definition shot::[7, run Cucumber] and paste it into our StepDefinitions class shot::[8, paste snippet] shot::[9]

So we need the actual messages that Lucy’s heard to be stored in an object that looks like a raw DataTable, so we can compare it to the ones we expect.

A array of array of Strings will do shot::[10], so we can just iterate over Lucy’s messages and create a new array. shot::[11]

.steps.js
[source, js]
----
include::../code/js/13-deepequal/features/step_definitions/steps.js[lines=53..57]
----

Now we can pass the array of actual messages and the data table of expected messages to the deepEqual method. shot::[12, write code to call deepEqual]

.steps.js
[source, js]
----
include::../code/js/13-deepequal/features/step_definitions/steps.js[lines=56]
----

shot::[13,runs cucumber]

Oops! It looks like we made a typo in our scenario. We should have included exclamation marks on the expected messages.shot::[14] Well, at least this gives you a chance to see the output from deepEqual when the tables are different. We see the expected values prefixed with a plus, and the actual values prefixed with a minus.

Let’s fix just one of these shot::[15, add exclamation mark] so you can see how the output from deepEqual changes.

.hear_shout.feature
[source,gherkin]
----
include::../code/js/14-fix-first-typo/features/hear_shout.feature[lines=39]
----

shot::[16,run cucumber]
The matching bagels! line no longer has a minus,shot::[17] and for the mismatched row, the actual value still has a minus,shot::[18] and the expected value has a plus.shot::[19]

Let’s fix this last typo shot::[20, add another exclamation mark], and we should be green again.

.hear_shout.feature
[source,gherkin]
----
include::../code/js/15-fix-second-typo/features/hear_shout.feature[lines=40]
----

shot::[21,run cucumber]

Great.
